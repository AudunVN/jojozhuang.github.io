---
layout: note
key: note
title: "Data Structure - HashTable"
index: 309
category: dsa
image: note/dsa.png
date: 2016-03-09
postdate: 2016-03-09
tags: [Hash, HashMap, HashTable]
---

> Implement a generic HashTable/HashMap with Separate Chaining technique by using linked list.

## 1. Concepts in Hash Table(or HashMap)
### 1.1 Hash Code and Compressor
`Hash code` is an Integer number (random or nonrandom). In Java every Object has its own hash code. We will use the hash code generated by JVM in our `hash function` and to compress the hash code we `modulo(%)` the hash code by size of the hash table. So modulo operator is `compressor` in our implementation.
### 1.2 Hash Function
`Hash function` hashes (converts) a number in a large range into a number in a smaller range. This smaller range corresponds to the index numbers in an array.  
```java
private int hashFunc(K key) {
    int hashCode = key.hashCode();
    int index = hashCode % numBuckets;
    return index;
}
```
### 1.3 Collision
If multiple keys has same hashCode, then collision occurs. Approaches to solve collision:
* Open Addressing: move to an empty cell. `clustering` issue may happen.
* Separate Chaining: store values in linked list instead of themselves.

### 1.4 Open Addressing Vs Separate Chaining  
If open addressing is to be used, double hashing seems to be the preferred system by a small margin over quadratic probing. The exception is the situation in which plenty of memory is available and the data won’t expand after the table is created; in this case linear probing is somewhat simpler to implement and, if load factors below 0.5 are used, causes little performance penalty.  
If the number of items that will be inserted in a hash table is `unknown` when the table is created, `separate chaining is preferable` to open addressing. Increasing the load factor causes major performance penalties in open addressing, but performance degrades only linearly in separate chaining.
When in doubt, use separate chaining. Its drawback is the need for a linked list class, but the payoff is that adding more data than you anticipated won’t cause performance to slow to a crawl.

### 1.5 Load Factor and Rehashing
`Load Factor` is the ratio of the number of items in a hash table to its size. If the total number of buckets is 10 and 7 of them got filled now, the load factor is 7/10=0.7.

In our implementation whenever we add a key value pair to the Hash Table we check the load factor if it is greater than 0.7 we double the size of our hash table.

## 2. Implementing HashMap
### 2.1 Structure of HashMap
An array list contains Hash Nodes. Each node can have none or multiple descendant nodes. They have the same index, but contains different hashcode.
![image](/public/notes/data-structure-hashtable/hashmap.png){:width="800px"}  
* [Diagrams on Google Slides](https://docs.google.com/presentation/d/1B0kYSS92tQ98Y7WsAcY9ypafoKf9QYSiUkc0_hK20pQ/edit?usp=sharing)

### 2.2 Common Operations for HashMap
* get(key): returns the value corresponding to the key if the key is present in HashMap
* add(key, value): adds new valid key, value pair to the HashMap, if already present updates the value
* remove(key): removes the key, value pair
* size(): return the size of the HashMap
* isEmpty(): returns true if size is zero

### 2.3 HashNode
HashNode is a storage unit for storing date. It has the `next` attribute pointing to the next hashnode, behaves like a linked list.
```java
public class HashNode<K, V> {
    public K key;
    public V val;
    public HashNode<K, V> next;
    public HashNode(K key, V val) {
        this.key = key;
        this.val = val;
        this.next = null;
    }
}
```
### 2.4 HashMap
Generic HashMap.
```java
public class HashMap<K, V> {
    // bucketArray is used to store array of chains
    private ArrayList<HashNode<K, V>> bucketList;
    // Current capacity of array list
    private int numBuckets;
    // Current size of array list
    private int size;

    // Constructor (Initializes capacity, size and empty chains.
    public HashMap() {
        bucketList = new ArrayList<>();
        numBuckets = 10;
        size = 0;

        // Create empty chains
        for (int i = 0; i < numBuckets; i++) {
            bucketList.add(null);
        }
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    // Returns value for a key
    public V get(K key) {
        // Find head of chain for given key
        int bucketIndex = hashFunc(key);
        HashNode<K, V> head = bucketList.get(bucketIndex);

        // Search key in chain
        while (head != null) {
            if (head.key.equals(key)) {
                return head.val;
            }
            head = head.next;
        }

        // If key not found
        return null;
    }

    // Adds a key value pair to hash
    public void add(K key, V value) {
        // Find head of chain for given key
        int bucketIndex = hashFunc(key);
        HashNode<K, V> head = bucketList.get(bucketIndex);

        // Check if key is already present
        while (head != null) {
            if (head.key.equals(key)) {
                head.val = value;
                return;
            }
            head = head.next;
        }

        // Insert key in chain
        size++;
        head = bucketList.get(bucketIndex);
        HashNode<K, V> newNode = new HashNode<K, V>(key, value);
        newNode.next = head; // add to header
        bucketList.set(bucketIndex, newNode);

        // If load factor goes beyond threshold, then double hash table size
        if ((1.0*size)/numBuckets >= 0.7) {
            ArrayList<HashNode<K, V>> tempList = bucketList;
            bucketList = new ArrayList<>();
            numBuckets = 2 * numBuckets; // double the capacity
            size = 0;
            for (int i = 0; i < numBuckets; i++) {
                bucketList.add(null);
            }

            for (HashNode<K, V> headNode : tempList) { // traverse array
                while (headNode != null) { // traverse each linked list
                    add(headNode.key, headNode.val);
                    headNode = headNode.next;
                }
            }
        }
    }

    // Method to remove a given key
    public V remove(K key) {
        // Apply hash function to find index for given key
        int bucketIndex = hashFunc(key);

        // Get head of chain
        HashNode<K, V> head = bucketList.get(bucketIndex);

        // Search for key in its chain
        HashNode<K, V> prev = null;
        while (head != null) {
            // If Key found
            if (head.key.equals(key)) {
                break;
            }

            // Else keep moving in chain
            prev = head;
            head = head.next;
        }

        // If key was not there
        if (head == null) {
            return null;
        }

        // Reduce size
        size--;

        // Remove key
        if (prev != null) {
            prev.next = head.next;
        } else {
            bucketList.set(bucketIndex, head.next);
        }

        return head.val;
    }

    // hash function
    private int hashFunc(K key) {
        int hashCode = key.hashCode();
        int index = hashCode % numBuckets;
        return index;
    }
}
```

## 3. HashMap in Java
TreeMap, HashMap, LinkedHashMap, WeakHashMap

For thread-unsafe hashmap, infinite loop may occur during rehashing. One thread is setting node1.next to node2. Meanwhile, another thread is setting node2.next = node1. Cycle exists in the node list.

## 4. Source Files
* [Source files for HashMap on GitHub](https://github.com/jojozhuang/DataStructure/tree/master/HashMap)
* [Diagrams on Google Slides](https://docs.google.com/presentation/d/1B0kYSS92tQ98Y7WsAcY9ypafoKf9QYSiUkc0_hK20pQ/edit?usp=sharing)

## 5. Reference
* [Java.util.HashMap in Java](https://www.geeksforgeeks.org/java-util-hashmap-in-java/)
* [Implementing our Own Hash Table with Separate Chaining in Java](https://www.geeksforgeeks.org/implementing-our-own-hash-table-with-separate-chaining-in-java/)
